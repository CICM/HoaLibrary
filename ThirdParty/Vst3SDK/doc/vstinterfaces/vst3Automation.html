<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VST 3 Interfaces: Parameters and Automation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxysmtg.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="vst3Automation">Parameters and Automation </a></h1><h2><a class="anchor" id="vst3ParameterIntro">
Parameters</a></h2>
<ul>
<li>Up to 2^32 parameters can be exported. (<a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#ab6ffbb8e3bf6f4829ab1c9c23fe935a1" title="Returns the number of parameters exported.">Steinberg::Vst::IEditController::getParameterCount</a>). The Plug-in has to assign a unique 32-bit identifier to each exported parameter. Please note that it is not allowed to change this assignment at any time. In particular a Plug-in must not perform any reconfigurations that lead to a different set of automatable parameters. The only allowed variation is to add or remove parameters in a future Plug-in version, but keep in mind that automation data can get lost when parameters are removed. <br/>
 <br/>
</li>
<li>Usually the host is unaware of a parameter's semantics. However there are a few important exceptions that the controller has to announce using the <a class="el" href="structSteinberg_1_1Vst_1_1ParameterInfo.html#a8ffba1d4311e48ae488bc118f20d7edb" title="ParameterFlags (see below).">Steinberg::Vst::ParameterInfo::flags</a> :<ul>
<li><b>Bypass</b> : If the Plug-in performs bypass processing itself, it has to export an according parameter and flag it with kIsBypass. It is highly recommended that this bypass parameter is provided by Effect Plug-in. If the Plug-in does not export such a parameter, the host could perform bypass processing and the Plug-in process call will be discontinued. Only one bypass parameter is allowed. The Plug-in should save the state of this bypass parameter like other parameters (when getState and setState are used)</li>
<li><b>Program</b> : If the Plug-in supports program lists (see <a class="el" href="vst3Units.html">Units</a>), each 'unit' of the Plug-in needs to export a program selector parameter. Such parameter is not allowed to be automated when the affected parameters are flagged as automatable as well. A host can display program parameters at exposed locations of its GUI. <br/>
 <br/>
</li>
</ul>
</li>
<li>The controller must support the conversion to a string for any exported parameter. The conversion method <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#aab2f0b853e75361d331b667e7893962e" title="Gets for a given paramID and normalized value its associated string representation...">Steinberg::Vst::IEditController::getParamStringByValue</a> must provide a result for any possible normalized parameter value. <br/>
 <br/>
</li>
<li>Parameter values are always transmitted in a normalized representation [0.0, 1.0].</li>
</ul>
<dl class="user"><dt><b>Representation of parameter values</b></dt><dd>A Plug-in parameter usually has more than one representation. The GUI of a Plug-in can display something that appears to be a single parameter, but it might control multiple processing parameters at the same time. Or the GUI representation displays a scale-transformed representation of a DSP-parameter. <br/>
<br/>
 Somewhere on the way from the GUI to the DSP-algorithm this transformation has to be performed. The host does not and must not know anything about DSP-parameters, but it is responsible for reporting parameter changes to the processor. According to this, the processor is the only place where a transformation can happen and all parameters always have to match the GUI representation. <br/>
<br/>
 Does this fit into the idea of separating GUI and processing? No problem so far - it is a separation of duties, nothing more. The processor component and the controller component have to work on the same internal Plug-in model. The controller knows how this model has to be presented in GUI. The processor knows how the model has to be translated into DSP-parameters. <br/>
 The VST 3 interfaces suggest a normalized value representation for the a part of this model (the part that is exported as parameters). This means every value has to be inside the range from 0.0 to 1.0.</dd></dl>
<dl class="user"><dt><b>Parameter styles / 'Step Count'</b></dt><dd>Although values are transmitted in a normalized format, the host needs to know some details of the parameter's displayed GUI representation. When editing automation data for example, the host must know the nature of a parameter expressed in its 'step count' (see <a class="el" href="structSteinberg_1_1Vst_1_1ParameterInfo.html#ac1efeff62e4ba9aea101c3327e0b5c4d">Steinberg::Vst::ParameterInfo::stepCount</a>). <br/>
<br/>
 <b> Step count semantics </b>:<ul>
<li>0 : A continuous parameter. Any normalized value has an exact mapping (0 = there are no steps between the values)</li>
<li>1 : A discrete parameter with 2 states like [on/off] [yes/no] etc. (1 = there is one step between these states)</li>
<li>2 : A discrete parameter with 3 states [0,1,2] or [3,5,7] (2 = there are two steps between these states)</li>
<li>3 : etc...</li>
</ul>
</dd></dl>
<dl class="user"><dt><b>Conversion of normalized values</b></dt><dd>The controller and the processor have to deal with normalized parameter values.<ul>
<li>Step count 0 : Continuous parameters simply need to be mapped accordingly</li>
<li>Step count n : Discrete parameters need a little bit more care<ul>
<li>Normalize: <div class="fragment"><pre class="fragment"> <span class="keywordtype">double</span> normalized = discreteValue / (double) stepCount; 
</pre></div></li>
<li>Denormalize : <div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> discreteValue = min (stepCount, normalized * (stepCount + 1)); 
</pre></div></li>
</ul>
</li>
</ul>
<br/>
 <b> Example: </b> Step Count 3 <div align="center">
<img src="valuerange.jpg" alt="valuerange.jpg"/>
</div>
</dd></dl>
<p><br/>
 <br/>
</p>
<h2><a class="anchor" id="vst3AutomationIntro">
Automation</a></h2>
<p>A host that supports parameter automation is dependent on a proper cooperation of the component owning these parameters. One intention in the design of the VST 3 interfaces was to reduce the amount of possible mistakes for an implementation. The separation of processor and controller enforces that all parameter changes have to be handled by the host in a defined way. And additionally this way allows the host to store the changes as automation data. Nevertheless there are some more things to consider:</p>
<dl class="user"><dt><b>No automated parameter must influence another automated parameter</b></dt><dd></dd></dl>
<p>The prime example for this is the automation of preset changes. A preset change can lead to the change of all 'normal' parameters. So if automation data already has been recorded for these parameters and the preset change is recorded as well: who wins? This question can not be answered and the problem can only be resolved by avoiding it. This is why automation of preset changes is not allowed by default.</p>
<dl class="user"><dt><b>Problems</b></dt><dd></dd></dl>
<p>A fix value range from 0.0 to 1.0 simplifies the handling of parameters in some ways, but there are problems: <br/>
</p>
<ul>
<li><b> Non-linear Scaling </b> <br/>
 If the DSP representation of a value does not scale in a linear way to the exported normalized representation (which can happen when a decibel scale is used for example), the edit controller must provide a conversion to a plain representation. This allows the host to move automation data (being in GUI representation) and keep the original value relations intact. (<a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#a849747dc98909312b4cdbdeea82dbae0" title="Returns for a given paramID and a normalized value its plain representation (for...">Steinberg::Vst::IEditController::normalizedParamToPlain</a> / <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#ae9706616ae6d938bbf102954f8f2f110" title="Returns for a given paramID and a plain value its normalized value.">Steinberg::Vst::IEditController::plainParamToNormalized</a>). <br/>
 <br/>
</li>
<li><b> Changes in future Plug-in versions </b> <br/>
 Take a discrete parameter for example that controls an option of three choices. If the host stores normalized values as automation data and a new version of a Plug-in invented a fourth choice, the automation data will be invalid now. So either the host has to store denormalized values as automation or it must recalculate the automation data accordingly. <br/>
 <br/>
</li>
</ul>
<h3><a class="anchor" id="vst3automationRecording">
Automation Recording</a></h3>
<p>Automation recording is performed by the host of course. In doing so it is essential for the host to know the start and the end of a manipulation. Therefore the Plug-in must operate the <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html" title="Host callback interface for an edit controller.">Steinberg::Vst::IComponentHandler</a> interface in the following way: <br/>
</p>
<ul>
<li>The begin of a manipulation must be signaled via <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#a8456ad739430267a12dda11a53fe9223" title="To be called before calling a performEdit (e.g.">Steinberg::Vst::IComponentHandler::beginEdit</a> <br/>
<br/>
</li>
<li>Changes of parameters are reported via <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#a135d4e76355ef0ba0a4162a0546d5f93" title="Called between beginEdit and endEdit to inform the handler that a given parameter...">Steinberg::Vst::IComponentHandler::performEdit</a> <br/>
<br/>
</li>
<li>The end of a manipulation must be signaled via <a class="el" href="classSteinberg_1_1Vst_1_1IComponentHandler.html#ae380206486b11f000cad7c0d9b6e877c" title="To be called after calling a performEdit (e.g.">Steinberg::Vst::IComponentHandler::endEdit</a> <br/>
<br/>
</li>
</ul>
<p>The Plug-in must stick to the order of these callbacks. Otherwise automation recording could not work correctly. While it is easy to claim this, an implementation can bring up difficulties. Each type of GUI control and the way it is operated along with the nature of the controlled parameter requires specific considerations. To address the most common cases:</p>
<dl class="user"><dt><b>Sliders &amp; Knobs </b></dt><dd>These kind of controls usually control continuous parameters and they are usually operated using the mouse. This common case is most simple to handle: On mouse-click-down call beginEdit (followed by performEdit when the control allows a jump), on mouse-drag call performEdit and on mouse-click-up call endEdit. <br/>
<br/>
</dd></dl>
<p>Trouble starts with the <b>Mouse wheel</b>: There simply is nothing like a defined start or end when the wheel is operated - each wheel event arrives out of the blue. The only way to enable proper automation recording in this case is the usage of a timer. <br/>
 <br/>
</p>
<ul>
<li>A dutiful Plug-in implementation should call beginEdit when the first wheel event is handled and start a timer (followed by the first call to performEdit). Further wheel events that arrive inside of the timeout interval are reported with performEdit and the timer is restarted. When the timeout period has passed without further events endEdit should be called and the timer can be removed. <br/>
 <br/>
</li>
</ul>
<ul>
<li>But since it is the host's task to record automation data, one can say that it shall be the host's task to care about the timer in this case as well. This is the reason for the exception to the rule:</li>
</ul>
<p><br/>
 Mouse wheel events can be reported without beginEdit and endEdit to the host. The host must be prepared to receive a performEdit without a previous call of beginEdit for a parameter and handle the timeout itself.</p>
<dl class="user"><dt><b>Buttons / Radio Groups / Popup Menus</b></dt><dd>These kind of controls usually control discrete parameters and simply switch the state of something. A proper handling is to call beginEdit, performEdit and endEdit in a row. The affected parameter has to be exported to the host with the correct step count since discrete parameters have to be handled differently than continuous parameters in regard to automation. <br/>
<br/>
 Mouse wheel handling usually is not supported for buttons, but sometimes for pop-up menus. Discrete parameters do not require the usage of a timer in order to be recorded correctly. <br/>
<br/>
 So the Plug-in should call the 3 functions in a row for each wheel event - again the other option is to omit beginEdit and endEdit, only make sure to report the discrete nature of the parameter to the host correctly.</dd></dl>
<dl class="user"><dt><b>Text Input</b></dt><dd>For reporting the results of any text input value change, regardless if a continuous or a discrete parameter is affected, always call beginEdit, performEdit and endEdit in a row. <br/>
 <br/>
</dd></dl>
<h3><a class="anchor" id="vst3automationPlayback">
Automation Playback</a></h3>
<p>In VST 3, automation playback is the task of the Plug-in and it is the host's task to provide the automation data. The only way for a parameter change to arrive in the processor is the processing call. Indeed, receiving parameter changes from the edit controller and playing back automation data is one and the same thing. <br/>
</p>
<p>Of course the need to do all transformations from the normalized GUI representation to the DSP representation produces some overhead. Performing sample accurate automation requires even more overhead, since the DSP value must be calculated for each single sample. While this can not be avoided totally, it is the choice of the Plug-in implementation of how much processing time should be spent on automation accuracy. The host always transmits value changes in a way that allows a sample accurate reconstruction of the underlying automation curve. The Plug-in is responsible for the realization.</p>
<dl class="user"><dt><b>GUI playback</b></dt><dd>The host is responsible for updating the Plug-in GUI when automation data is transmitted to the processor. This is realized by frequent calls of <a class="el" href="classSteinberg_1_1Vst_1_1IEditController.html#aded549c5b0f342a23dee18cc41ece6b8" title="Sets the normalized value to the parameter associated to the paramID.">Steinberg::Vst::IEditController::setParamNormalized</a>.</dd></dl>
 <hr width="100%" size="2" align="left" />  <b><a class="el" href="classSteinberg_1_1Vst_1_1IParameterChanges.html" title="All parameter changes of a processing block.">Steinberg::Vst::IParameterChanges</a></b> <br/>
 All parameter changes of a processing block. <ul>
<li>[host imp]</li>
<li>[released: 3.0.0]</li>
</ul>
This interface is used to transmit any changes that shall be applied to paramaters in the current processing block. A change can be caused by GUI interaction as well as automation. They are transmitted as a list of queues (<a class="el" href="classSteinberg_1_1Vst_1_1IParamValueQueue.html" title="Queue of changes for a specific parameter.">IParamValueQueue</a>) containing only queues for paramaters that actually did change. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSteinberg_1_1Vst_1_1IParamValueQueue.html" title="Queue of changes for a specific parameter.">IParamValueQueue</a>, <a class="el" href="structSteinberg_1_1Vst_1_1ProcessData.html" title="Any data needed in audio processing.">ProcessData</a> </dd></dl>
  <hr width="100%" size="2" align="left" />  <b><a class="el" href="classSteinberg_1_1Vst_1_1IParamValueQueue.html" title="Queue of changes for a specific parameter.">Steinberg::Vst::IParamValueQueue</a></b> <br/>
 Queue of changes for a specific parameter. <ul>
<li>[host imp]</li>
<li>[released: 3.0.0]</li>
</ul>
The change queue can be interpreted as segment of an automation curve. For each processing block a segment with the size of the block is transmitted to the processor. The curve is expressed as sampling points of a linear approximation of the original automation curve. If the original already is a linear curve it can be transmitted precisely. A non-linear curve has to be converted to a linear approximation by the host. Every point of the value queue defines a linear section of the curve as a straight line from the previous point of a block to the new one. So the Plug-in can calculate the value of the curve for any sample position in the block.<b>Implicit Points:</b> <br/>
 In each processing block the section of the curve for each parameter is transmitted. In order to reduce the amount of points, the point at block position 0 can be omitted.</p>
<ul>
<li>If the curve has a slope of 0 over a period of multiple blocks, only one point is transmitted for the block where the constant curve section starts. The queue for the following blocks will be empty as long as the curve slope is 0.</li>
<li>If the curve has a constant slope other than 0 over the period of several blocks, only the value for the last sample of the block is transmitted. In this case the last valid point is at block position -1. The processor can calculate the value for each sample in the block by using a linear interpolation: <div class="fragment"><pre class="fragment"><span class="keywordtype">double</span> x1 = -1; <span class="comment">// position of last point related to current buffer</span>
<span class="keywordtype">double</span> y1 = currentParameterValue; <span class="comment">// last transmitted value</span>

<a class="codeRef" doxygen="base.tag:../base/" href="../base/namespaceSteinberg.html#a4ca2d97e571b049be6f4cdcfaa1ab946">int32</a> pointTime = 0;
<a class="code" href="group__vst3typedef.html#ga11508dccaa352a24d0ae6585a93f4641" title="parameter value type">ParamValue</a> pointValue = 0;
<a class="code" href="classSteinberg_1_1Vst_1_1IParamValueQueue.html#ac10774ecd1a00877d5d1b315894be1a7" title="Gets the value and offset at a given index.">IParamValueQueue::getPoint</a> (0, pointTime, pointValue);

<span class="keywordtype">double</span> x2 = pointTime;
<span class="keywordtype">double</span> y2 = pointValue;

<span class="keywordtype">double</span> slope = (y2 - y1) / (x2 - x1);
<span class="keywordtype">double</span> offset = y1 - (slope * x1);

<span class="keywordtype">double</span> curveValue = (slope * bufferTime) + offset; <span class="comment">// bufferTime is any position in buffer</span>
</pre></div></li>
</ul>
<b>Jumps:</b> <br/>
 A jump in the automation curve has to be transmitted as two points: one with the old value and one with the new value at the next sample position.<div align="center">
<img src="automation.jpg" alt="automation.jpg"/>
</div>
 <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classSteinberg_1_1Vst_1_1IParameterChanges.html" title="All parameter changes of a processing block.">IParameterChanges</a>, <a class="el" href="structSteinberg_1_1Vst_1_1ProcessData.html" title="Any data needed in audio processing.">ProcessData</a> </dd></dl>
</p>
<p><br/>
 Back to <b><a class="el" href="index.html#vst3Contents">Contents</a></b> <br/>
 </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&nbsp;</span>Properties</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<html>

<head>
	<title>Empty</title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
	<meta name="Author" content="mario">
</head>

<body>

<br/>
<hr width="100%" size="2" align="left" />
<div align=left>
Copyright &copy;2013 <a href="http://www.steinberg.net" target="_blank"><u>Steinberg Media Technologies GmbH</u></a>.
All Rights Reserved.
</div>
</body>

</html>
