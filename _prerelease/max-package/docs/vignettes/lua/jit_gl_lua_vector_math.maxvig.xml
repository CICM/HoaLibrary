<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="_c74_vig.xsl" type="text/xsl"?>
<vignette name="jit.gl.lua Vector Math" order="1">

<header1>jit.gl.lua Vector Math</header1>
<bodytext>
The vector math functions in <o>jit.gl.lua</o> are located in the <m>vec</m> module and are organized into six categories.  These categories are:
<ul>
<li>vec.vec2</li>
<li>vec.vec3</li>
<li>vec.vec4</li>
<li>vec.quat</li>
<li>vec.mat3</li>
<li>vec.mat4</li>
</ul>
The arguments to all of the vector math functions are tables containing the appropriate number of values for the data type.  For example a vec2 is a table with two elements, {1, 2}, while a mat3 has nine elements {1, 2, 3, 4, 5, 6, 7, 8, 9}.  The matrices are specified in column-major order so for a mat3, the first three elements are the first column, the second three the second column and so on.
</bodytext>
<header3>vec2</header3>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = vec2.equal(v1, v2)
</code>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = vec2.not_equal(v1, v2)
</code>
<code>res = vec2.dot(v1, v2)
</code>
<code>res = vec2.normalize(v)
</code>
<code>res = vec2.mult(v1, v2)
</code>
<code>res = vec2.scale(v, s)
</code>
<code>res = vec2.div(v1, v2)
</code>
<code>res = vec2.sub(v1, v2)
</code>
<code>res = vec2.add(v1, v2)
</code>
<code>res = vec2.mag_sqr(v)
</code>
<code>res = vec2.mag(v)
</code>
<code>res = vec2.negate(v)
</code>
<code>res = vec2.max(v1, v2)
</code>
<code>res = vec2.lerp(v1, v2, t)
</code>
<header3>vec3</header3>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = vec3.equal(v1, v2)
</code>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = vec3.not_equal(v1, v2)
</code>
<code>res = vec3.mult(v1, v2)
</code>
<code>res = vec3.scale(v, s)
</code>
<code>res = vec3.div(v1, v2)
</code>
<code>res = vec3.sub(v1, v2)
</code>
<code>res = vec3.add(v1, v2)
</code>
<code>res = vec3.mag_sqr(v)
</code>
<code>res = vec3.mag(v)
</code>
<code>res = vec3.negate(v)
</code>
<code>res = vec3.cross(v1, v2)
</code>
<code>res = vec3.dot(v1, v2)
</code>
<code>res = vec3.reflect(v1, v2)
</code>
<code><span style="color:#0c7f3d;">-- calculate the normal to a triangle defined by three points</span>
res = vec3.normal(p1, p2, p3)
</code>
<code>res = vec3.normalize(v)
</code>
<code>res = vec3.max(v1, v2)
</code>
<code>res = vec3.min(v1, v2)
</code>
<code>res = vec3.lerp(v1, v2, t)
</code>
<code>res = vec3.intersect_line_sphere(linepos1, linepos2, sphere_center, sphere_radius)
</code>
<code>res = vec3.axisx_from_quat(quat)
</code>
<code>res = vec3.axisy_from_quat(quat)
</code>
<code>res = vec3.axisz_from_quat(quat)
</code>
<code>res = vec3.transform_axisangle(axis, angle, v)
</code>
<code>res = vec3.mult_mat3(v, mat3)
</code>
<code>res = vec3.centroid3(v1, v2, v3)
</code>
<code>res = vec3.centroid4(v1, v2, v3, v4)
</code>

<header3>vec4</header3>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = vec4.equal(v1, v2)
</code>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = vec4.not_equal(v1, v2)
</code>
<code>res = vec4.mult(v1, v2)
</code>
<code>res = vec4.scale(v, s)
</code>
<code>res = vec4.div(v1, v2)
</code>
<code>res = vec4.sub(v1, v2)
</code>
<code>res = vec4.add(v1, v2)
</code>
<code>res = vec4.mag_sqr(v)
</code>
<code>res = vec4.mag(v)
</code>
<code>res = vec4.negate(v)
</code>
<code>res = vec4.dot(v1, v2)
</code>
<code>res = vec4.normalize(v)
</code>
<code>res = vec4.max(v1, v2)
</code>
<code>res = vec4.min(v1, v2)
</code>
<code>res = vec4.lerp(v1, v2, t)
</code>
<code>res = vec4.mult_mat4(v, mat4)
</code>

<header3>quat</header3>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = quat.equal(q1, q2)
</code>
<code><span style="color:#0c7f3d;">-- res is a 1 or 0 depending on equality</span>
res = quat.not_equal(q1, q2)
</code>
<code>res = quat.mult(q1, q2)
</code>
<code>res = quat.scale(q, s)
</code>
<code>res = quat.div(q1, q2)
</code>
<code>res = quat.add(q1, q2)
</code>
<code>res = quat.mag_sqr(q)
</code>
<code>res = quat.mag(q)
</code>
<code>res = quat.negate(q)
</code>
<code>res = quat.dot(q1, q2)
</code>
<code>res = quat.normalize(q)
</code>
<code>res = quat.max(q1, q2)
</code>
<code>res = quat.min(q1, q2)
</code>
<code>res = quat.slerp(q1, q2, t)
</code>
<code>res = quat.from_mat3(mat3)
</code>
<code>res = quat.from_mat4(mat4)
</code>
<code>res = quat.from_axis_angle(axis, angle)
</code>
<code>res = quat.conj(q)
</code>
<code>res = quat.from_euler(euler_angles)
</code>

<header3>mat3</header3>
<code>res = mat3.add(m1, m2)
</code>
<code>res = mat3.mult(m1, m2)
</code>
<code>res = mat3.transpose(m)
</code>
<code>res = mat3.mult_vec3(m, v)
</code>
<code>res = mat3.from_axisangle(axis, angle)
</code>
<code>res = mat3.from_uv(v1, v2)
</code>
<code>res = mat3.determinant(m)
</code>
<code>res = mat3.negate(m)
</code>
<code>res = mat3.from_mat4(mat4)
</code>
<code>res = mat3.from_quat(q)
</code>

<header3>mat4</header3>
<code>res = mat4.add(m1, m2)
</code>
<code>res = mat4.mult(m1, m2)
</code>
<code>res = mat4.transpose(m)
</code>
<code>res = mat4.mult_vec4(m, v)
</code>
<code>res = mat4.from_axisangle(axis, angle)
</code>
<code>res = mat4.from_uv(v1, v2)
</code>
<code>res = mat4.determinant(m)
</code>
<code>res = mat4.negate(m)
</code>
<code>res = mat4.from_quat(q)
</code>
<code>res = mat4.look_at(eye, center, up)
</code>
<code>res = mat4.frustum(left, right, bottom, top, near, far)
</code>
<code>res = mat4.perspective(fovy, aspect, near, far)
</code>
<code>res = mat4.ortho(left, right, bottom, top, near, far)
</code>

</vignette>