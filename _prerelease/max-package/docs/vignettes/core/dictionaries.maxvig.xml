<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<?xml-stylesheet href="_c74_vig.xsl" type="text/xsl"?>
<vignette name="Dictionaries">
	
	
	
	<header1>Dictionaries - Structured Data</header1>

	<bodytext>
		Max 6 introduces the concept of dictionaries, that is structured data which can be passed between objects.
	</bodytext>
	
	<bodytext>
		In Max we create patchers, which are collections of objects that act on data sent to their inlets. 
		Typically this data is simply a number or a symbol.  
		Sometimes the data is slight more complex: 
		a list combines numbers and symbols into a collection that you can pass to an object’s inlet. 
		There is no inherent structure to a list; lists are organized simply as one item after the other.
	</bodytext>



	<header2>Key-Value Pairs</header2>

	<bodytext>
		A dictionary is a new data type based on collections of key-value pairs.  
		Using a dictionary of terms for a spoken language as an analogy, 
		the keys are the terms and the definitions or descriptions for those terms are the value.  
		Each key in the dictionary is a unique symbol.  
		Each value may be a number, symbol, or list.
	</bodytext>

	<bodytext>
		Consider an example where you wish to pass a subpatcher a bundle of information to setup an ADSR envelope. 
		Using a list, you could do it like this:
	</bodytext>
	<code>
		20 40 -6 150 exp  no
	</code>

	<bodytext>
		The data in this example will make it through, 
		but the reading of this list is a little cryptic because the interpretation of this data requires prior knowledge.  
		A dictionary, on the other hand, 
		structures this data by tagging the values with keys that identify each piece of information:
	</bodytext>
	<code>
		attack:			20 ms
		decay:			40 ms
		sustain:		-6 db
		release:		150 ms
		shape:		exponential
		voice-stealing:	no
	</code>

	<bodytext>
		This dictionary is made up of 6 key-value pairs.  
		In a list format it may be onerous to also tag the values with their units, 
		but in the dictionary it is quite natural to do and so they have been added.
	</bodytext>
	
	
	
	<header2>Passing Dictionaries</header2>

	<bodytext>
		The most important thing that Dictionary objects communicate to each other is a name, 
		referring to a dictionary (a place in memory where data is stored).
		Dictionary objects output a message that only other Dictionary objects understand. 
		Unsurprisingly, that message is the word "dictionary" followed by a space and the name of a dictionary where data is stored.
		This message is communicated from one Dictionary object to another through a patch cord in the normal Max manner. 
	</bodytext>
	
	<bodytext>
		If you are familiar with Jitter, this is the same way that Jitter works to pass around matrices.
	</bodytext>
	
	<bodytext>
		The receiving Dictionary object receives the message in its inlet (most commonly the left inlet), 
		gets the data from the specified place in memory, 
		modifies the data in some way, 
		and sends the name of the modified data out its left outlet to all connected Dictionary objects. 
		In this way, tasks are performed by each object without necessarily knowing what the other objects are doing, 
		and each object gets the data it needs by looking at the appropriate place in memory. 
		Most Dictionary objects don't really do anything until they get a "dictionary" message from another Dictionary object, 
		telling them to look at that dictionary and do something with the data there.
	</bodytext>
	
	<bodytext>
		In many cases a Dictionary object will generate a unique name for its dictionary on its own. 
		In other cases, it is possible (and even desirable) to tell an object what name to use for a dictionary. 
		By explicitly naming a dictionary, we can cause objects to use that same memory space. 
	</bodytext>

		<!-- TODO: show some screenshots of examples -->
<!--
		<bodytext>
		  <img src="images/js1.png" />
		</bodytext>
-->

	<header3>Caveats and Subtleties</header3>

	<bodytext>
		Although passing dictionaries by reference instead of by value permits us to create system that is simpler 
		and faster than passing by value, there are some side-effects and implications of which you should be aware.  
		This is particularly true when there is a bifurcation in the patcher’s structure, 
		which is to say that patch cords are fanning out from an outlet of an object to multiple objects or multiple inlets. 
	<!-- simple math example with numbers
	Consider the following example: (removed for now)
	-->
 </bodytext>
	
	<!-- simple math example with numbers -->
	<!-- explain pass by value behavior (expected) -->
	<!-- explain pass by reference behavior (unexpected) -->

	<bodytext>
	<!-- simple math example with numbers
	How to handle the situation... (removed for now)
	--> 
		If you need to pass by value, then you can explicitly control this by ‘cloning’ a dictionary.  
		To clone a dictionary, simply pass a dictionary into a ‘dict’ object as in the following example.
	</bodytext>

	<!-- example of cloning -->
	
	<!-- commented out for now 	
	
	<header2>Using Dictionaries with Ordinary Objects</header2>
	<bodytext>
		Some practical examples...  e.g. dict.pack
	</bodytext>
	
  -->	

	<header2>Dictionary Syntax</header2>

	<bodytext>
		It is sometimes useful to represent the contents of a dictionary as a string of text.
	</bodytext>
	
	<bodytext>
		Dictionary syntax is a list of atoms representing N key-value pairs.
		Keys and values are separated by a colon.
		If there is no value specified for a key, then a default value of "*" is used
		(indicating a wildcard for objects that use dictionary values for matching or validation).
		As an example, a dictionary of three pigs mapped to the kinds of houses they built can
		be represented in dictionary syntax like this:
	</bodytext>
	
	<code>
		pig1 : straw pig2 : sticks pig3 : bricks 
	</code>
	
	<bodytext>
		One case where this is handy is for sending the contents of a dictionary over a network using objects
		such as <o>udpsend</o>.  
		To "serialize" a dictionary into such a textual representation, the <o>dict.serialize</o> object fits the bill.
		The <o>dict.deserialize</o> object does the opposite: it converts a string of text into a named dictionary.
	</bodytext>
	
	<bodytext>
		Dictionary Syntax is also used to specify dictionary contents as arguments to objects.
		Two examples are <o>dict.pack</o> and <o>dict.route</o>.  
		The <o>dict.pack</o> object uses a dictionary specified as arguments to configure its inlets,
		which are mapped to keys that you provide, and the default values for those keys.
		The <o>dict.route</o> object uses a dictionary specified as arguments as a schema (or model)
		dictionary against which to validate incoming dictionaries.
	</bodytext>


	<header2>Accessing Dictionaries in JavaScript</header2>

	<bodytext>
		Analogous to the <o>dict</o> object in the graphical patcher environment, the <code>Dict</code> object in JS creates a dictionary and associates it with a name.  If the name is already associated with an existing dictionary, then this Dict object references that dictionary.
	</bodytext>
	
	<bodytext>
	The following code creates two dictionaries.  
	The first dictionary refers to the dictionary named 'ark'.
	The second dictionary had no name specified, so it will generate a unique symbol to use as a name.
	You can find out what name it was assigned by accessing the name attribute.
	</bodytext>

	<code>
		var d1 = new Dict("ark");
		var d2 = new Dict;

		var name = d2.name;
		post("The second Dict is named", name);		
	</code>

	<header3>Methods</header3>
	
	The Dict object defines the following methods.
	<code>
		getnames()											: returns a list of all dictionary names currently in use in the environment
		getkeys()												: returns a list of all keys in the dictionary
		get("foo")											: return the value associated with the key named "foo"
		set("foo", "bar")								: for the key "foo", set the value to "bar"
		push_to_coll("a_coll")					: export the contents of the dictionary to a coll object named "a_coll"
		pull_from_coll("another_coll")	: import the contents of a coll object named "another_coll" into this dictionary
		export_json("filename.json")		: export the contents of the dictionary to a file in the JSON format
		import_json("filename.json")		: import a JSON file named "filename.json" into this dictionary
	</code>

	<header3>Attributes</header3>
	
	The Dict object defines the following attributes.
	<code>
		name		: the name associated with this dictionary
	</code>


	<header2>Writing Dictionary Objects in Java</header2>
	<bodytext>
		Support for using Dict objects in <o>mxj</o> mirrors that of the implementation for JavaScript.
	</bodytext>



	<header2>Writing Dictionary Objects in C</header2>
	<bodytext>
		A complete API for objects passing dictionaries is available to C developers in the Max
		Software Development Kit.
	</bodytext>



	<header2>See Also</header2>
	
	<ul>
		<li><a href="http://en.wikipedia.org/wiki/Associative_array">http://en.wikipedia.org/wiki/Associative_array</a></li>
		<li><o>dict</o></li>
		<li><o>dict.pack</o></li>
		<link type="vignette" module="js" name="jsglobal" anchor="embedmessage">JavaScript in Max</link>.
  </ul>

</vignette>
