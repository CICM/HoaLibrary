<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet href="_c74_vig.xsl" type="text/xsl"?>
<vignette name="Gen Overview" order="1">
	<header1>
	Gen
</header1>
	<header2>
	Why Use Gen?
	</header2>
	<bodytext>
	<b>
	General
	</b>
	<ul>
	<li>You want to create processes that can't be efficiently achieved with ordinary Max/MSP/Jitter objects</li>
	<li>You want to program visually at a low level while getting the performance of compiled C or GLSL code</li>
	<li>You want to use a concise text based expression language (codebox) rather than visual programming or coding in GLSL</li>
	<li>You want to avoid having to compile separate windows and macintosh versions (and in the future, 64-bit application binaries)</li>
	<li>You want to design new algorithms and see or hear them immediately</li>
	<li>You want to design an algorithm that can run on the CPU or GPU, on Windows and Mac</li>
	</ul>

	<b>
	Examples
	</b>
	<ul>
	<li>arbitrary new oscillator and filter designs using single-sample feedback loops with <o>gen~</o></li>
	<li>reverbs and physical models using networks of short feedback delays with <o>gen~</o></li>
	<li>sample-accurate buffer~ processing such as waveset distortions with <o>gen~</o></li>
	<li>efficient frequency-domain processing such as spectral delays using <o>gen~</o> inside pfft~</li>
	<li>custom video processing filters as fast as C compiled externals with <o>jit.pix</o>, and graphics card accelerated with <o>jit.gl.pix</o></li>
	<li>geometry manipulation and generation with <o>jit.gen</o></li>
	<li>particle system design with <o>jit.gen</o></li>
	<li>iso-surface generation with distance fields in <o>jit.gen</o></li>
	</ul>

	<b>
	Performance improvements
	</b>
	<ul>
	<li>consolidation of chained MSP operators or jit.ops and other MSP/Jitter objects that can be combined into one meta-object</li>
	<li>replacement for <o>jit.expr</o> with performance and interface improvements</li>
	<li>You want to be able to have a simple way to make use of the GPU for image processing both in visual and textual form</li>
	</ul>
	</bodytext>
	
	<bodytext>
			Gen refers to a technology in Max representing a new approach to the relationship 
			between patchers and code. The patcher is the traditional Max environment - a graphical 
			interface for linking bits of functionality together. With embedded scripting such as the 
			<o>js</o> 
			object text-based coding became an important part of working with Max as it was no longer 
			confined to simply writing Max externals in C. Scripting however still didn’t alter the 
			logic of the Max patcher in any fundamental way because the boundary between patcher 
			and code was still the object box. Gen represents a fundamental change in that relationship.
		</bodytext>
	<bodytext>
			The Gen patcher is a new kind of Max patcher where Gen technology is accessed. 
			Gen patchers are specialized for specific domains such as audio (MSP) and matrix 
			and texture processing (Jitter). The MSP Gen object is called 
			<o>gen~</o>. The Jitter Gen objects are 
			<o>jit.gen</o>, 
			<o>jit.pix</o> 
			and 
			<o>jit.gl.pix</o>. 
			Each of these Gen objects contains within it a Gen patcher. While gen patchers share 
			many of the same capabilities, each Gen object has functionality specific to its domain. 
			For example, Gen patchers in 
			<o>gen~</o> 
			have delay lines while Gen patchers in 
			<o>jit.gen</o> 
			have vector types.
		</bodytext>
	<ul>
		<li>
			<link module="gen" name="gen_common_operators" type="vignette">A listing of operators common to all Gen objects</link>
		</li>
		<li>
			<link module="gen" name="gen~_operators" type="vignette">A listing of operators common to all the gen~ object</link>
		</li>
		<li>
			<link module="gen" name="gen_jitter_operators" type="vignette">A listing of operators common to all Gen Jitter objects</link>
		</li>
	</ul>
	<bodytext>
			Gen patchers describe the calculations a Gen object performs. When you’re 
			editing a Gen patcher, you’re editing the internal calculations of the Gen object. In order to make use of the computations 
			described in its Gen patcher, a Gen object compiles the patcher into a language called 
			<link module="gen" name="gen_genexpr" type="vignette"><i>GenExpr</i></link>
			. GenExpr bridges the patcher and code worlds with a common representation, which a Gen object turns 
			into target code necessary to perform its calculations. 
			<o>gen~</o>, 
			<o>jit.gen</o>, and 
			<o>jit.pix</o> 
			transparently generate and compile native CPU machine code on-the-fly, while 
			<o>jit.gl.pix</o> 
			does the same for GPU code (GLSL). When working with Gen objects, you’re writing your own custom 
			pre-compiled MSP and Jitter objects without having to leave Max.
		</bodytext>
	<bluebox>
		<header2>
		Creating a Gen Patch
	</header2>
		<ul>
			<li>
			Click in a blank space in your unlocked patcher window and type "n" (new) to create a new object box
			with a cursor. Type in the name of the Gen object you want to create -
			<o>gen~</o>
			, 
			<o>jit.gen</o>
			,
			<o>jit.pix</o>
			or
			<o>jit.gl.pix</o>
			. The object will appear.
		</li>
			<li>
			Double-click on the object you just created to open its Gen patcher window. You'll see
			that your patch includes two inlets and one outlet by default.
		</li>
		</ul>
		<bodytext>
			<img src="images/gen-patcher-window.png"/>
		</bodytext>
	</bluebox>
	<br/>
	<space/>
	<header2>
			The Gen Patcher Window
		</header2>
	<bodytext>
		Like the regular Max patcher window, the Gen patcher window contains a number of buttons on the toolbar
		that you can use to perform regular patching tasks. You will recognize some of them from the Max patcher window.
	</bodytext>
	<bodytext>
		The <i>Lock/unlock</i> button toggles the locked state of the patcher window.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar1.png"/>
	</bodytext>
	<bodytext>
		The <i>Patcher Windows</i> button lets you open a 
		<link module="core" name="patcher_views" type="vignette">new view of the patcher window</link>
		.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar2.png"/>
	</bodytext>
	<bodytext>
		The <i>New Object</i> button duplicates the act of typing an "n" - it creates a new blank object box with a cursor, ready to be named.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar3.png"/>
	</bodytext>
	<bodytext>
		The <i>Show Grid/Hide Grid</i> button shows or hides the 
		<link module="core" name="grid" type="vignette">grid</link>.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar4.png"/>
	</bodytext>
	<bodytext>
		The <i>Reset</i> will reset the current Gen code compilation to its default values.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar5.png"/>
	</bodytext>
	<bodytext>
		The <i>Compile</i> button is used to manually compile the patch in the Gen window. The button is greyed out
		unless you have disabled Auto-compilation and then added an operator or a new connection to your patch.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar6.png"/>
	</bodytext>
	<bodytext>
		The <i>Disable Auto-Compile/Enable Auto-Compile</i> button is used to toggle autocompilation of 
		the patch in the Gen patcher window. By default, autocompilation is on so that you can hear and
		see the results of your patching as you work.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar7.png"/>
	</bodytext>
	<bodytext>
		The <i>Show Status Bar/Hide Status Bar</i> button shows or hides the 
		<link module="core" name="status_bar" type="vignette">Status Bar</link>.
	</bodytext>
	<bodytext>
		<img src="images/gen_window_toolbar8.png"/>
	</bodytext>
	<header2>
			Patching in Gen
		</header2>
	<bodytext>
			Gen patchers look similar to Max patchers, but there are a few important differences:
		</bodytext>
	<ul>
		<li>
			Although they share a collection of
			<link module="gen" name="gen_common_operators" type="vignette">common operators</link>
			, the set of objects (or “operators”) available in a Gen patcher in the
			<link module="gen" name="gen~_operators" type="vignette">gen~ (Gen audio)</link>
			and
			<link module="gen" name="gen_jitter_operators" type="vignette">Gen Jitter</link>
			domains are different. This is also true of
			<link module="gen" name="gen_genexpr" type="vignette">GenExpr</link>
			, as well.
		</li>
		<li>
			There are no messages. All operations are synchronous, rather like MSP patching. Because of this, 
			there are no UI objects (sliders, buttons etc.). However the 
			<m>param</m> 
			operator can be used to receive message-rate controls from the normal Max world. There is no need to 
			differentiate hot and cold inlets, or the order in which outlets ‘fire’, since all objects and outlets always fire 
			at the same time.
		</li>
		<li>
			There are no 
			<m>send</m>
			and 
			<m>receive</m> 
			operators in Gen patcher. Gen patchers are connected to the outside world through the 
			<m>in</m>
			,
			<m>out</m>
			, and
			<m>param</m>
			operators. In 
			<o>gen~</o>
			, there are some additional operators such as 
			<m>history</m>, 
			<m>data</m> and 
			<m>buffer</m>
			that are controllable with messages to 
			<o>gen~</o>
			. See the 
			<o>gen~</o> 
			section for the details.
		</li>
		<li>
			The usual distinction between int and float numbers does not apply to Gen patchers. At the Gen patcher level, everything is a 64-bit floating point number.
		</li>
		<li>
			The 
			<m>codebox</m> 
			is a special operator for Gen patchers, in which more complex expressions 
			can be written using the 
			<link module="gen" name="gen_genexpr" type="vignette">GenExpr</link>
			language.
		</li>
	</ul>
	<bodytext>
			Gen patchers can be embedded within the 
			<o>gen~</o>
			, 
			<o>jit.gen</o>
			, etc. object, or can be loaded from external files (with 
			<i>.gendsp</i> 
			or 
			<i>.genjit</i> 
			file extensions respectively) using the 
			<m>@gen</m> 
			attribute of 
			<o>gen~</o>
			, 
			<o>jit.gen</o>
			, etc. objects.
		</bodytext>
	<header2>
			Auto-compile
		</header2>
	<bodytext>
			By default, the compilation process occurs in the background while you are editing, 
			so that you can see or hear the results immediately. This auto-compilation process 
			can be disabled using the ‘Auto-Compile’ toggle in the Gen patcher toolbar. 
			Compilation can also be triggered using the hammer icon in the Gen patcher toolbar 
			or any codebox toolbar.
		</bodytext>
	<bluebox>
		<header2>
		Enabling and Disabline Auto-compilation in a Gen Patcher
	</header2>
		<ul>
			<li>
			Click on the Auto-compile button in the Gen patcher window to disable autocompilation.
			When you do, the circle in the button will turn white and change to an Enable Auto-Compile button.
		</li>
		</ul>
		<bodytext>
			<img src="images/gen-disable-autocompile.png"/>
		</bodytext>
		<ul>
			<li>
			When you add a new operator to your patch or make a new connection, the Compile button will become active
			in the Gen patcher toolbar.
		</li>
		</ul>
		<bodytext>
			<img src="images/gen-compile-button.png"/>
		</bodytext>
		<ul>
			<li>
			Click on the Compile button to compile the current version of the patch. You'll
			see/hear the results, and the Compile button will be greyed out until you add another
			operator or connection.
		</li>
		</ul>
	</bluebox>
	<br/>
	<space/>
	<header2>
			Gen Operators
		</header2>
	<bodytext>
			Gen operators represent the functionality involved in a Gen patcher. They can exist as 
			object boxes in a patcher or as functions or variables in 
			GenExpr 
			code. They are the 
			link between the patcher and code worlds.
		</bodytext>
	<bodytext>
			Gen operators take arguments and attributes just like Max objects, but these are purely 
			declarative. Since there is no messaging in Gen patchers, the attribute value set when 
			the operator is created does not change. Attributes are most often used to specialize 
			the implementation of the process the operator represents (such as setting a maximum value for 
			<m>param</m>
			using the 
			<m>@max</m>
			attribute.)
		</bodytext>
	<bodytext>
			In many cases, the specification of an object’s argument effectively replaces the 
			corresponding inlet. This is possible in Gen because there is no messaging and 
			all processing is synchronous. For example, the 
			<m>+</m>
			operator takes two inputs, but if an argument is given only one input needs to be 
			specified as an inlet:
	</bodytext>
	<bodytext>
		<img src="images/gen-01.png"/>
	</bodytext>
	<bodytext>
			An inlet with no connected patchcord uses a default value instead (often zero, but 
			check the inlet assist strings for each operator). An inlet with multiple connections 
			adds them all together, just as with MSP signal patchcords:
		</bodytext>
	<bodytext>
		<img src="images/gen-02.png"/>
	</bodytext>
	<header2>
		Standard Operators
	</header2>
	<bodytext>
			Many standard objects behave like the corresponding Max or MSP object, such as all 
			arithmetic operators (including the reverse operators like 
			<m>!-</m>
			, 
			<m>!/</m> 
			etc.), trigonometric operators (
			<m>sin</m>
			, 
			<m>cosh</m>
			, 
			<m>atan2</m>
			etc.), standard math operators (
			<m>abs</m>
			, 
			<m>floor</m>
			, 
			<m>pow</m>
			, 
			<m>log</m>
			, etc.), boolean operators (
			<m>&gt;</m>
			, 
			<m>==</m>
			, 
			<m>&amp;&amp;</m>
			(also known as 
			<m>and</m>
			) etc.) and other operators such as 
			<m>min</m>
			, 
			<m>max</m>
			, 
			<m>clip</m>
			(also known as 
			<m>clamp</m>
			), 
			<m>scale</m>
			, 
			<m>fold</m>
			, 
			<m>wrap</m>
			, 
			<m>cartopol</m>
			, 
			<m>poltocar</m>
			etc. In addition there are some operators in common with GLSL (
			<m>fract</m>
			, 
			<m>mix</m>
			, 
			<m>smoothstep</m>
			, 
			<m>degrees</m>
			, 
			<m>radians</m> 
			etc.) and some drawn from the 
			<o>jit.op</o> 
			operator list (
			<m>&gt;p</m>
			, 
			<m>==p</m>
			, 
			<m>absdiff</m>
			etc.).	
		</bodytext>
	<bodytext>
			There are several predefined constants available (
			<m>pi</m>
			,
			<m>twopi</m>
			,
			<m>halfpi</m>
			,
			<m>invpi</m>
			,
			<m>degtorad</m>
			,
			<m>radtodeg</m>
			,
			<m>e</m>
			,
			<m>ln2</m>
			,
			<m>ln10</m>
			,
			<m>log10e</m>
			,
			<m>log2e</m>
			,
			<m>sqrt2</m>
			,
			<m>sqrt1_2</m>
			and the same in capitalized form as 
			<m>PI</m>
			,
			<m>TWOPI</m>
			etc), which can be used in place of a numeric argument to any operator:
		</bodytext>
	<bodytext>
		<img src="images/gen-03.png"/>
	</bodytext>
	<header2>
		Argument Expressions
	</header2>
	<bodytext>
		For all objects that accept numeric arguments (e.g. [+ 2.] or [max 1.]) argument expressions can be used in their place.  Argument expressions are simple statements with known inputs such as constants, gen patcher inputs, and parameter names.  Many gen operators can be used as argument expressions, particularly the math operators (sqrt, cos, ...).  Argument expressions can help simplify gen patchers where all that is needed is the calculation of a constant that isn't pre-defined such as 3*pi/2.  For example, in the patch below:		
	</bodytext>
	<bodytext>
		<img src="images/gen-14.png"/>
	</bodytext>
	<bodytext>
	there is a scale operator with an argument of sqrt(2)*2.  Similarly, the mul (*) operator has an argument expression of 1+in2.  Since in2 is the GenExpr equivalent of [in 2], it can be used in an argument expression.
	</bodytext>
	<header2>
		Send and Receive
	</header2>
	<bodytext>
	<m>send</m> and <m>receive</m> within gen patchers can be used to connect objects without patchcords.  In gen patchers, <m>send</m> and <m>receive</m> can only be used locally.  They will not connect to <m>send</m> and <m>receive</m> objects in other gen patchers or gen subpatchers.  <m>send</m> and <m>receive</m> take a name argument that determines connectivity.
	</bodytext>
	<bodytext>
		<img src="images/gen-13.png"/>
	</bodytext>
	<bodytext>
		There can be multiple <m>send</m> and <m>receive</m> objects with the same name without issue.  If there are multiple <m>send</m> objects with the same name, they will be summed just as if multiple patchcords were connected to the same inlet.  If there are multiple <m>receive</m> objects with the same name, they will all receive identical input from their corresponding <m>send</m> objects.
	</bodytext>
	<header2>
		Subpatchers and Abstractions
	</header2>
	<bodytext>
	Subpatchers and abstraction in gen objects behave practically identically to standard Max subpatchers and abstractions.  In gen objects, subpatchers are created with the <m>gen</m> operator.  If the <m>gen</m> operator is given the name of a gen patcher as an argument, it will use it to set the titlebar of the subpatcher.
	</bodytext>
	<bodytext>
		<img src="images/gen.subpatcher-01.png"/>
	</bodytext>
	<bodytext>
		Abstractions, as with standard max abstractions, are instantiated by creating an object with the name of the gen file to load as the abstraction.  For example, if an operator named <m>differential</m> is created, gen will look for the file differential.gendsp with gen~ and differential.genjit with the jitter gen objects.  Instantiating abstractions this way is shorthand for setting the <m>file</m> attribute on the <m>gen</m> operator.  For example, creating an operator <m>differential</m> is equivalent to <m>gen @file differential</m>.
	</bodytext>
	<bodytext>
		<img src="images/gen.subpatcher-02.png"/>
	</bodytext>
	<header3>
		Subpatcher/Abstractions and Parameters
	</header3>
	<bodytext>
		Just like normal gen patchers, gen subpatchers and abstractions can also contain parameters.  When used in subpatchers and abstractions, parameters behave like named inlets with default values.  If nothing is connected to a parameter in a subpatcher or abstraction, the parameter will be a constant and its value will be its default.
	</bodytext>
	<bodytext>
		<img src="images/gen.subpatcher-03.png"/>
	</bodytext>
	<bodytext>
		In the above example, the subpatcher has a parameter <m>scale</m> with a default of 1.  In the subpatcher's sidebar, we see this represented in the GenExpr code as
	</bodytext>
<code>
Param scale(<span style="color:#1b39f5;">1.</span>);
</code>
	<bodytext>
		However, in the parent gen patcher, the parameter gets converted into a constant because nothing is connected to the parameter.  The first line in the parent patcher's GenExpr sidebar reads:
	</bodytext>
<code>
scale_1 = <span style="color:#1b39f5;">1.</span>;
</code>
	<bodytext>
	which is the default value of the scale parameter.
	</bodytext>
	<bodytext>
	Since subpatcher and abstraction parameters don't create their own inlets to connect objects to, there is a special operator called <m>setparam</m> that can be connected to any inlet for this specific purposes.  <m>setparam</m> connects all of its inputs to a named parameter in a subpatcher or abstraction.  It requires an argument specifying the name of the parameter to connect to.
	</bodytext>
	<bodytext>
	When <m>setparam</m> is connected to a parameter, the parameter changes from being a constant to a dynamic variable equivalent to the value at the input of the <m>setparam</m> object.
	</bodytext>
	<bodytext>
		<img src="images/gen.subpatcher-04.png"/>
	</bodytext>
	<bodytext>
	Notice that the code in the parent subpatcher has changed from a constant to:
	</bodytext>
	<code>
setparam_1 = <span style="color:#be230d;">in2</span>;
</code>
	<bodytext>
	<m>in</m> is conected to the inlet of the <m>setparam</m> object so the scale parameter takes on that value.
	</bodytext>
	<header2>
	The gen~ Object
</header2>
	<bodytext>
			The <o>gen~</o> object is specifically for operating on MSP audio signals. 
			Unlike MSP patching however, operations in a Gen patcher are combined into a single chunk of machine code, making possible many more optimizations that can make complex processes more efficient, and allow you to design processes which 
			must operate on a per-sample level, even with feedback loops.
		</bodytext>
		<bodytext>
			Working in gen~ opens up scope to design signal processes at a lower level, even per-sample. Because of this, many operators take duration arguments in terms of samples (where 
			the equivalent MSP objects would use milliseconds). 
		</bodytext>
	<header2>
		gen~ Operators
	</header2>
	<bodytext>
			In addition to the 
			standard Gen operators
			, which are often similar to the 
			equivalent MSP objects (such as 
			<m>clip</m>
			, 
			<m>scale</m>
			, 
			<m>minimum</m>
			, 
			<m>maximum</m>
			, 
			etc.), many of the operators specific to the 
			<o>gen~</o> 
			domain mirror existing MSP objects to make the transition to 
			<o>gen~</o> 
			easier. There are familiar converters (
			<m>dbtoa</m>
			, 
			<m>atodb</m>
			, 
			<m>mtof</m>
			, 
			<m>ftom</m>
			, 
			<m>mstosamps</m>
			, 
			<m>sampstoms</m>
			), oscillators (
			<m>phasor</m>
			, 
			<m>train</m>
			, 
			<m>cycle</m>
			, 
			<m>noise</m>
			), and modifiers (
			<m>delta</m>
			, 
			<m>change</m>
			, 
			<m>sah</m>
			, 
			<m>triangle</m>). In addition there are some lower-level operators to avoid invalid or inaudible outputs (
			<m>isnan</m>
			, 
			<m>fixnan</m>
			, 
			<m>isdenorm</m>
			, 
			<m>fixdenorm</m>
			,
			<m>dcblock</m>
			).
		</bodytext>
	<bodytext>
			A global value of 
			<m>samplerate</m>
			is available both as an object, and as a valid value for an argument of 
			any object.
		</bodytext>
	<bodytext>
		<img src="images/gen-04.png"/>
	</bodytext>
	<header2>
		History
	</header2>
	<bodytext>
			In general, the Gen patcher will not allow a feedback loop (since it represents a synchronous process). 
			To create a feedback loop in 
			<o>gen~</o>
			, the 
			<m>history</m> 
			operator can be used. This represents a single-sample delay (a <i>Z-1</i> operation). Thus the inlet to the
			<m>history</m>
			operator will set the outlet value for the next sample (put another way, the outlet value of the 
			<m>history</m>
			operator is the inlet value from the previous sample). Multiple 
			<m>history</m>
			operators can be chained to create <i>Z-2</i>, <i>Z-3</i> delays, but for longer and more flexible delay operators, use the 
			<m>delay</m>
			operator.
		</bodytext>
	<bodytext>
		<img src="images/gen-05.png"/>
	</bodytext>
	<bodytext>
			A history operator in a Gen patcher can also be named, making it available for external control, 
			just like a 
			<m>param</m>
			parameter.
		</bodytext>
	<header2>
		Delay
	</header2>
	<bodytext>
			The
			<m>delay</m>
			operator delays a signal by a certain amount of time, specified in samples. The maximum delay 
			time is specified as an argument to the 
			<m>delay</m>
			object. You can also have a multi-tap delay by specifying the number of taps in the second argument. 
			Each tap will have an inlet to set the delay time, and a corresponding outlet for the delayed signal.
		</bodytext>
	<bodytext>
		Note that the delay operator is not currently supported in GenExpr.
	</bodytext>
	<bodytext>
			The 
			<m>delay</m>
			operator can be used for feedback loops, like the history operator, if the 
			<m>@feedback</m>
			attribute is set to 1 (the default). The <m>@interp</m>
			attribute specifies which kind of interpolation is used:
		</bodytext>
	<ul>
		<li><b>none</b> 
			or 
			<b>step</b>: No interpolation.
		</li>
		<li><b>linear</b>: Linear interpolation.
		</li>
		<li><b>cosine</b>: Cosine interpolation.
		</li>
		<li><b>cubic</b>: Cubic interpolation.
		</li>
		<li><b>spline</b>: Catmull-Rom spline interpolation.
		</li>
	</ul>
	<header2>
		Data and Buffer
	</header2>
	<bodytext>
			For more complex persistent storage of audio (or any numeric) data, 
			<o>gen~</o> offers two objects: 
			<m>data</m>
			and 
			<m>buffer</m>, 
			which are in some ways similar to MSP’s 
			<o>buffer~</o> 
			object. A 
			<m>data</m>
			or
			<m>buffer</m>
			object has a local name, which is used by various operators in the Gen patcher to 
			read and write the 
			<m>data</m>
			or 
			<m>buffer</m>
			contents, or get its properties.
		</bodytext>
	<bodytext>
		Note that the data and buffer objects are not currently supported in GenExpr, including all associated operators.
	</bodytext>
	<bodytext>
		<img src="images/gen-06.png"/>
	</bodytext>
	<bodytext>
			Reading the contents of a data or buffer can be done using the 
			<m>peek</m>
			, 
			<m>lookup</m>
			,  
			<m>wave</m>
			, 
			<m>sample</m>
			or 
			<m>nearest</m> 
			operators. The first argument for all of these operators is the local name of a data or buffer. 
			They all support single- or multi-channel reading (the second argument specifies the number of 
			channels, and the last inlet the channel offset, where zero is the default).
		</bodytext>
	<bodytext>
			All of these operators are essentially the same, differing only in defaults of their 
			attributes. The attributes are:
		</bodytext>
	<bodytext><m>@index</m>
			specifies the meaning of the first inlet:
		</bodytext>
	<ul>
		<li><b>samples</b>: The first inlet is a sample index into the data or buffer.
		</li>
		<li><b>phase</b>: Maps the range 0..1 to the whole data or buffer contents.
		</li>
		<li><b>lookup</b> 
			or 
			<b>signal</b>: Maps the range -1..1 to the whole data or buffer contents, like the MSP 
			<o>lookup~</o>
			object. 
		</li>
		<li><b>wave</b>: Adds extra inlets for start/end (in samples), driven by a 
			phase signal between these boundaries (0..1, similar to MSP’s 
			<o>wave~</o>
			object).
		</li>
	</ul>
	<bodytext><m>@boundmode</m>
			specifies what to do if the index is out of range:
		</bodytext>
	<ul>
		<li><b>ignore</b>: Indices out of bounds are ignored (return zero).
		</li>
		<li><b>wrap</b>: Indices out of bounds repeat at the opposite boundary.
		</li>
		<li><b>fold</b> or <b>mirror</b>: Indices wrap with palindrome behavior.
		</li>
		<li><b>clip</b> or <b>clamp</b>: Indices out of bounds use the value at the bound.
		</li>
	</ul>
	<bodytext><m>@channelmode</m> 
			specifies what to do if the channel is out of range. It has the same options as the 
			<m>@boundmode</m>
			attribute.
		</bodytext>
	<bodytext><m>@interp</m>
			specifies what kind of interpolation is used:
		</bodytext>
	<ul>
		<li><b>none</b> 
			or 
			<b>step</b>: No interpolation.
		</li>
		<li><b>linear</b>: Linear interpolation.
		</li>
		<li><b>cosine</b>: Cosine interpolation.
		</li>
		<li><b>cubic</b>: Cubic interpolation.
		</li>
		<li><b>spline</b>: Catmull-Rom spline interpolation.
		</li>
	</ul>
	<bodytext>
			The
			<m>nearest</m>
			operator defaults to <i>@index phase @interp none @boundmode ignore @channelmode ignore</i>.
		</bodytext>
	<bodytext>
			The
			<m>sample</m>
			operator  defaults to <i>@index phase @interp linear @boundmode ignore @channelmode ignore</i>.
		</bodytext>
	<bodytext>
			The
			<m>peek</m>
			operator  defaults to <i>@index samples @interp none @boundmode ignore @channelmode ignore</i>.
		</bodytext>
	<bodytext>
			The
			<m>lookup</m>
			operator  defaults to <i>@index lookup @interp linear @boundmode clamp @channelmode clamp</i>.
		</bodytext>
	<bodytext>
			The 
			<m>wave</m>
			operator defaults to <i>@index wave @interp linear @boundmode wrap @channelmode clamp</i>.
		</bodytext>
	<bodytext>
			Accessing the spatial properties of a 
			<m>data</m> 
			or 
			<m>buffer</m>
			objects is done using the 
			<m>dim</m>
			and 
			<m>channels</m>
			operators (or the outlets of the 
			<m>data</m> 
			or 
			<m>buffer</m>
			object itself), and writing is done using 
			<m>poke</m>
			(non-interpolating replace) or 
			<m>splat</m>
			(interpolating overdub).
		</bodytext>
	<bodytext>
			Briefly, 
			<m>data</m>
			should be thought of as a 64-bit buffer internal to the 
			<o>gen~</o>
			patcher, even though it can be copied to, and 
			<m>buffer</m> 
			should be thought of as an object which can read and write external 
			<o>buffer~</o> 
			data. The full differences between 
			<m>data</m>
			and 
			<m>buffer</m>
			are:
		</bodytext>
	<ul>
		<li>
			A 
			<m>data</m>
			object is local to the Gen patcher, and cannot be read outside of it. 
			On the other hand, a
			<m>buffer</m>
			object is a shared reference to an external MSP 
			<o>buffer~</o>
			object. Modifying the contents in a Gen buffer is directly modifying the contents of the MSP
			<o>buffer~</o>
			object it references.
		</li>
		<li>
			The
			<m>data</m>
			object takes three arguments to set its local name, its length (in samples) and number of channels. The
			<m>buffer</m>
			object takes an argument to set its local name, and an optional argument to specify the name of an MSP 
			<o>buffer~</o> 
			object to reference (instead of using the local name). 
		</li>
		<li>
			Setting the 
			<o>gen~</o> 
			attribute corresponding to a named 
			<m>data</m>
			object copies in values from the corresponding MSP 
			<o>buffer~</o>
			, while for a named
			<m>buffer</m>
			object it changes the MSP 
			<o>buffer~</o>
			referenced. The
			<m>buffer</m>
			object always has the size of the 
			<o>buffer~</o>
			object it references (which may change). The 
			<m>data</m> 
			object has the size of its initial definition, or the size of the 
			<o>buffer~</o> 
			object which was copied to it (whichever is smaller). 
		</li>
		<li>
			The
			<m>data</m>
			object always uses 64-bit doubles, while The
			<m>buffer</m>
			object converts from the bit resolution of the MSP 
			<o>buffer~</o>
			object (currently 32-bit floats) for all read and write operations, and may be less efficient.
		</li>
	</ul>
	<header2>
		Technical notes
	</header2>
	<bodytext>
			All operations in 
			<o>gen~</o>
			use 64-bit doubles.
		</bodytext>
	<bodytext>
			The compilation process for 
			<o>gen~</o> 
			Gen patchers and GenExprs includes 
			an optimization that takes into account the update rate of each operator, 
			so that any calculations that do not need to occur at sample rate (such as 
			arithmetic on the outputs of param operators) instead process at a slower rate (determined by the host patcher vector size) for efficiency.
		</bodytext>
	<header1>
	Jitter Gen Objects
</header1>
	<bodytext>
			There are three Gen objects in jitter: 
			<o>jit.gen</o>
			, 
			<o>jit.pix</o>
			, and 
			<o>jit.gl.pix</o>
			. The
			<o>jit.gen</o>
			and
			<o>jit.pix</o>
			objects process Jitter matrices similar to 
			<o>jit.expr</o>
			. The
			<o>jit.gl.pix</o> 
			object processes textures and matrices just like 
			<o>jit.gl.slab</o>
			. The
			<o>jit.gen</o> 
			object is a generic matrix processing object that can handle matrices with any planecount, type and dimension. 
			<o>jit.pix</o> 
			and 
			<o>jit.gl.pix</o>
			,on the other hand, are specifically designed for working with pixel data. They can handle data of any type, 
			but it must be two dimensional or less and have at most four planes.
		</bodytext>
	<header2>
		Jitter Operators
	</header2>
	<header3>
		Coordinates
	</header3>
	<bodytext>
			Jitter Gen patchers describe the processing kernel for each cell in a matrix or texture. 
			As the kernel is processing the input matrices, a set of coordinates is generated 
			describing the location of the current cell being processed. The objects are just 
			like the operators in 
			<o>jit.expr</o>
			. They are 
			<m>norm</m>
			, 
			<m>snorm</m>
			, and 
			<m>cell</m> 
			with the 
			<m>dim</m> 
			operator giving the dimensions of the input matrix. 
			<m>norm</m> 
			ranges from [0, 1] across all matrix dimensions and is defined as <i>norm = cell/dim</i>
			. 
			<m>snorm</m> 
			ranges from [-1, 1] across all matrix dimensions and is defined as <i>snorm = cell/dim*2-1</i>. 
			<m>cell</m> 
			gives the current cell index.
		</bodytext>
	<header3>
		Vectors
	</header3>
	<bodytext>
			Since Jitter matrices represent arrays of vector (more than one plane) data, all Gen operators 
			in Jitter can process vectors of any size, so Gen patchers once created work equally on any 
			vector size. The basic binary operators 
			<m>+</m>
			, 
			<m>-</m>
			, 
			<m>*</m>
			, 
			<m>/</m>
			, and
			<m>%</m>
			can take vector arguments as in <b>[+ 0.5 0.25 0.15]</b>
			, which will create an addition operator adding a vector with the three components to its input.  Also, the <m>param</m> operator can take vector default values as in <b>[param 1 2 3 4]</b>.  Parameters can have up to 32 values in <o>jit.gen</o> and 4 values in <o>jit.pix</o> and <o>jit.gl.pix</o>.
	</bodytext>
	<bodytext>
		<img src="images/gen-09.png"/>
	</bodytext>
	<bodytext>
			The
			<m>vec</m>
			operator creates vector constants and packs values together in a vector. It takes default 
			arguments for its components and casts all of its inputs to scalar values before packing 
			them together.
		</bodytext>
	<bodytext>
		<img src="images/gen-10.png"/>
	</bodytext>
	<bodytext>
			The
			<m>swiz</m>
			operator applies a swizzle operation to vectors. In GLSL and similar shading 
			languages, vector components can be accessed by indexing the vector with named planes. 
			For example in GLSL you might see 
		</bodytext>
	<code>
red = color.r 
	</code>
	<bodytext>
			or 
	</bodytext>
	<code>
redalpha = color.ra 
	</code>
	<bodytext>
			or even 
	</bodytext>
	<code>
val = color.rbbg
</code>
	<bodytext>
			This type of operation is referred to as <i>swizzling</i>. The 
			<m>swiz</m> 
			operator can take named arguments using the letters 
			<b>r</b>
			,
			<b>g</b>
			,
			<b>b</b>
			,
			<b>a</b>
			, as well as 
			<b>x</b>
			,
			<b>y</b>
			,
			<b>z</b>
			,
			<b>w</b>
			in addition to numeric indices starting at 0. The letters are convenient for vectors 
			with four or less planes, but for larger vectors numeric indices must be used. 
			The compilation process automatically checks any swiz operation so arguments indexing 
			components larger than the vector being processed will be clamped to the size of the vector.
		
		</bodytext>
	<bodytext>
		<img src="images/gen-11.png"/>
	</bodytext>
	<bodytext>
			In addition, there are the basic vector operations for spatial calculations. These are 
			<m>length</m>
			,
			<m>normalize</m>
			,
			<m>cross</m>
			,
			<m>dot</m>
			, and
			<m>reflect</m>
			.
		</bodytext>
	<header3>
		Sampling
	</header3>
	<bodytext>
			Sampling operators are one of the most powerful features of Jitter Gen patchers. 
			Sampling operators take an input and a coordinate in the range [0, 1] as an argument, 
			returning the data at the coordinate’s position in the matrix or texture. The first 
			argument always has to be a Gen patcher input while the second argument is an N-dimensional 
			vector whose size is equal to the dimensionality of the input it is processing.
			If the coordinate argument is outside of the range [0, 1], it will be converted to 
			a value within the range [0, 1] according to its boundmode function. Possible 
			boundmodes are 
			<m>wrap</m>
			,
			<m>mirror</m>
			, and
			<m>clamp</m>
			, where 
			<m>wrap</m>
			is the default.
		</bodytext>
	<bodytext>
		<img src="images/gen-12.png"/>
	</bodytext>
	<bodytext>
			The two sampling operators in Jitter Gen patchers are 
			<m>sample</m>
			and
			<m>nearest</m>. 
			The 
			<m>sample</m> 
			operator samples values form a matrix using N-dimensional linear interpolation. The 
			<m>nearest</m> 
			operator will simply grab the value from the closest cell.
		</bodytext>
	<header3>
		Geometry
	</header3>
	<bodytext>
			Jitter Gen patchers include a suite of objects for generating surfaces. These include 
			most of the shapes available in the 
			<o>jit.gl.gridshape</o> 
			object. Each surface function returns two values: the vertex position and the vertex 
			normal. The geometry operators are 
			<m>sphere</m>
			,
			<m>torus</m>
			,
			<m>circle</m>
			,
			<m>plane</m>
			,
			<m>cone</m>
			, and
			<m>cylinder</m>
			.
		</bodytext>
	<header3>
		Color
	</header3>
	<bodytext>
			There are two color operators in Jitter Gen patchers. They are 
			<m>rgb2hsl</m>
			and 
			<m>hsl2rgb</m>
			. They convert between the Red Green Blue color space and the Hue Saturation Luminance 
			color space. If the input to these objects has an alpha component, the alpha will be 
			passed through untouched.
		</bodytext>
	<header2>	
		jit.gen
	</header2>
	<bodytext>
			The 
			<o>jit.gen</o> 
			object is a general purpose matrix processing object. It compiles Gen patchers 
			into native machine code representing the kernel of an N-dimensional matrix processing 
			routine. It follows the Jitter matrix planemapping conventions for pixel data 
			with planes [0-4] as the ARGB channels. 
			<o>jit.gen</o> 
			can have any number of inlets and outlets, but the matrix format for the 
			different inputs and outputs is always linked. In other words, the matrix format 
			(planecount, type, dimensions) of the first inlet determines the matrix format for 
			all other inputs and outputs.
			<o>jit.gen</o> 
			makes use of parallel processing just like other parallel aware objects 
			in Jitter for maximum performance with large matrices.			
		</bodytext>
	<bodytext>
			How a matrix is processed by 
			<o>jit.gen</o>
			is dependent on the input planecount, type, and dimension of the input matrices. 
			In addition, there is a precision attribute that sets the type of the processing 
			kernel. The default value for precision is auto. Auto precision automatically 
			adapts the type of the kernel dependent upon the matrix input type. In auto 
			mode, the following mapping between input matrix type and kernel processing 
			type is used:
		</bodytext>
	<ul>
		<li>
			char maps to fixed
		</li>
		<li>
			long maps to float64
		</li>
		<li>
			float32 maps to float32
		</li>
		<li>
			float64 maps to float64
		</li>
	</ul>
	<bodytext>
			Other possible values for the precision attribute are fixed, float32, and 
			float64. Fixed precision is the only setting that doesn’t correspond to a 
			Jitter matrix type. Fixed precision specifies a kernel type that performs 
			a type of floating point calculation with integers using a technique called 
			fixed-point arithmetic. It’s very fast and provides more precision than 8-bit 
			char operations without incurring the cost of converting to a true 
			floating-point type. However, fixed-point arithmetic calculations have 
			more error that can sometimes be visible when using the sampling operators. 
			If there are noticeable artifacts, simply increase the internal precision 
			to float32.
		</bodytext>
	<header2>	
		jit.pix
	</header2>
	<bodytext>
			The
			<o>jit.pix</o> 
			object is a matrix processing object specifically for pixel data. When processing 
			matrices representing video and images, 
			<o>jit.pix</o>
			is the best object. Internally, data is in RGBA format always. If the input 
			has less than four planes, 
			<o>jit.pix</o> 
			will convert it to RGBA format according to the following rules:
		</bodytext>
	<ul>
		<li>
			1-plane, Luminance format, L to LLL1 (Luminance for RGB and 1 for Alpha)
		</li>
		<li>
			2-plane Lumalpha format, LA to LLLA (Luminance for RGB and Alpha for Alpha)
		</li>
		<li>
			3-plane RGB format, RGB to RGB1 (RGB for RGB and 1 for Alpha)
		</li>
		<li>
			4-plane, ARGB format, ARGB to RGBA (changes the order of the channels internally)
		</li>
	</ul>
	<bodytext>
			The output of 
			<o>jit.pix</o> 
			is always a 4-plane matrix in ARGB format, which is the standard Jitter 
			pixel planemapping. Like 
			<o>jit.gen</o>
			, 
			<o>jit.pix</o> 
			compiles Gen patchers into C++ and makes use of Jitter’s parallel 
			processing system. 
			<o>jit.pix</o> 
			also has a precision attribute that operates exactly the same was as it 
			does in 
			<o>jit.gen</o>
			.		
		</bodytext>
	<header2>	
		jit.gl.pix
	</header2>
	<bodytext>
			The
			<o>jit.gl.pix</o> 
			object
			is a matrix and texture processing object specifically for pixel data that 
			operates just like 
			<o>jit.gl.slab</o>
			. The only difference between the two is that 
			<o>jit.gl.pix</o> 
			compiles its patcher into GLSL while 
			<o>jit.gl.slab</o> 
			reads it from a shader file. Like 
			<o>jit.pix</o>
			, 
			<o>jit.gl.pix</o> 
			uses an internal RGBA pixel format. 
		</bodytext>
	<header2>	
		Technical notes
	</header2>
	<header3>
		<b>Numerical Values in the Kernel</b>
	</header3>
	<bodytext>
	All numerical values in Jitter Gen patches are conceptually floating point values.  This is the case 
	even for fixed precision kernels.  It is particularly important to remember this when dealing with char 
	matrices.  All char matrices are converted to the range [0, 1] internally.  On output, this 
	range is mapped back out to [0, 255] in the char type.  A char value of 1 is equivalent to the floating 
	point value of 1/255.
	</bodytext>
	<bodytext>
		<img src="images/gen-jit-01.png"/>
	</bodytext>
	<bodytext>
		When using the comparison operators (<m>==</m>, <m>!=</m>, <m>&lt;</m>, <m>&lt;=</m>, <m>&gt;</m>, <m>&gt;=</m>), it's 
		particularly important to keep in mind the floating point nature of Gen patcher internal values because 
		of their inherent imprecision.  Instead of directly testing for equality for example , it's more effective 
		to test for whther a value falls within a certain small range (epsilon).  In the example above, the 
		<m>absdiff</m> operator calculates how far a value is from 1/255 and then the <m>&lt;</m> op tests to see 
		if it's within the threshold of error.
	</bodytext>
	<header3>
		jit.pix vs. jit.gl.pix
	</header3>
	<bodytext>
			For the most part <o>jit.pix</o> and <o>jit.gl.pix</o> will behave 
			identically despite one being CPU-oriented and the other GPU-oriented. 
			The differences have to do with differences in behavior between how 
			matrix inputs are handled with <o>jit.pix</o> and how texture inputs 
			are handled with 
			<o>jit.gl.pix</o>
			. All of the inputs to 
			<o>jit.pix</o> 
			will adapt in size, type, and dimension to the left-most input. As a 
			result, all input matrices within a 
			<o>jit.pix</o>
			processing kernel will have the same values for the cell and dim 
			operators. In 
			<o>jit.gl.pix</o>
			, inputs can have different sizes. In 
			<o>jit.gl.pix</o>
			, the values for the cell and dim operators are calculated from the properties 
			of the left-most input (<i>in1</i>). A future version may include per-input cell and dim 
			operators, but for now this is not the case.
		</bodytext>
	<bodytext>
			Since the sampling operators take normalized coordinates in the range [0, 1], 
			differently sized input textures will still be properly sampled using the 
			norm operator since its value is independent of varying input sizes. 
			However, in 
			<o>jit.gl.pix</o> 
			the sample and nearest operators behave 
			differently than with 
			<o>jit.pix</o>
			. How a texture is sampled is determined 
			by the properties of the texture. As a consequence, sample and nearest behave 
			the same in 
			<o>jit.gl.pix</o>
			. To enable nearest sampling, set the 
			<m>@filter</m>
			attribute to nearest. For linear interpolation, set 
			<m>@filter</m>
			 to linear (the default).
		</bodytext>
</vignette>